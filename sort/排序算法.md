### 第一组： bubbleSort/InsertionSort/SelectionSort

这是我们要学习的第一组排序算法，为什么将冒泡排序,选择排序和插入排序放在一起讲?是因为这三种排序他们对应的是同样的一种抽象思维:

这种思维是把一个数组，分成了两部分来看，第一部分是未排序的数组。第二部分是已经排序的数组，我们要做的是不断的减少未排序数组的尺寸，增加已排序一种数组的尺寸。当未排序数组的尺寸减小为0时，我们可以说整个数排序完成.

这个角度我们就可以理解为什么这些排序算法需要两个```for```循环。我们也可以理解这两个复```for```循环的开始条件和终止条件。我们以冒泡排序为例，当我们还未对数组进行排序时，未排序数组的尺寸就是原始数组的尺寸，
已经排序的数组的尺寸为```0```。

这就是为什么在第一个for循环中冒泡排序的开始条件```int i```，它的初始值是```0```，因为代表着**数组已排序元素的个数**，因为我们从未对数组进行排序，所以它的初始值是```0```，它的结束条件是 ```i > n```. 这里的n指的就是数组的尺寸，**即数组已排序数组的个数=数组个数时，排序完成**

第二个```for```循环的作用是进行一次遍历，找出未排序数组的最大/最小值。根据动图（**动图在对应的方法中**）我们可以得知冒泡排序是将以排序的数组放在数组的后方，未排序的数组是数组的前半部分。
而第二个```for```循环是要将未排序的数据中最大或者最小的一个元素，，经过swap的方式放在已排序数组的第一位。

这就是为什么这三种排序方法。他们```for```循环中开始条件和终止条件是有区别的。**因为有方法是将已排序数组放在数组的前端，未排序数组放在后端，而有的算法是相反的**。:

但是他们的本质是相同的。
1. 第一个```for```循环永远代表着数组中已经排序的数组的个数，它的停止条件永远是数组中所有的元素都经过了排序。
2. 第二个```for```循环，同样也永远代表着未排序数组的范围，也就是我们需要遍历的范围，只不过因为未排序数组的位置有可能在数组的前端或者后端，导致了第二个```for```循环，他的初始条件和截止条件在取值上有差别。
